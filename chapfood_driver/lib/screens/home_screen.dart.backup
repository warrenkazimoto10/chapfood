import 'package:flutter/material.dart';
import 'package:google_fonts/google_fonts.dart';
import 'package:google_maps_flutter/google_maps_flutter.dart';
import 'package:geolocator/geolocator.dart' as geo;
import 'package:provider/provider.dart';
import 'package:flutter/services.dart';
import 'dart:async';

import '../constants/app_colors.dart';
import '../utils/text_styles.dart';
import '../services/theme_service.dart';
import '../services/location_service.dart';
import '../services/session_service.dart';
import '../services/order_service.dart';
import '../services/google_maps_routing_service.dart';
import '../services/realtime_debug_service.dart';
import '../services/delivery_code_service.dart';
import '../models/order_model.dart';
import '../models/driver_model.dart';
import '../widgets/chapfood_logo.dart';
import '../widgets/notification_badge.dart';
import '../widgets/driver_status_toggle.dart';
import '../widgets/order_notification_card.dart';
import '../widgets/delivery_code_modal.dart';
import '../widgets/delivery_panel.dart';
import '../widgets/map/directional_marker.dart';
import 'profile_screen.dart';
import 'revenue_history_screen.dart';
import 'package:supabase_flutter/supabase_flutter.dart';

class HomeScreen extends StatefulWidget {
  const HomeScreen({super.key});

  @override
  State<HomeScreen> createState() => _HomeScreenState();
}

class _HomeScreenState extends State<HomeScreen> {
  GoogleMapController? _mapController;
  geo.Position? _currentPosition;
  geo.Position? _previousPosition; // Pour calculer le bearing
  double? _currentBearing; // Direction en degr√©s
  Set<Marker> _markers = {};
  Set<Polyline> _polylines = {};
  BitmapDescriptor? _driverMarkerIcon;
  BitmapDescriptor? _clientMarkerIcon;
  bool _isDrivingMode = false; // Mode conduite activ√©
  Timer? _routeUpdateTimer; // Timer pour mettre √† jour l'itin√©raire
  RouteInfo? _currentRoute; // Informations de l'itin√©raire actuel
  DriverModel? _currentDriver;
  List<OrderModel> _availableOrders = [];
  OrderModel? _currentOrder;
  bool _isDriverAvailable = true;
  bool _isLoading = true;
  bool _isOnDelivery = false;
  bool _isModalOpen = false; // Nouvelle variable pour contr√¥ler l'√©tat du modal
  bool _isDeliveryCardVisible =
      true; // Variable pour contr√¥ler l'affichage du card de livraison
  StreamSubscription<List<OrderModel>>? _ordersSubscription;
  Timer? _locationTimer;
  Timer? _notificationTimer;

  @override
  void initState() {
    super.initState();
    _initializeApp();
  }

  @override
  void dispose() {
    _locationTimer?.cancel();
    _notificationTimer?.cancel();
    _ordersSubscription?.cancel();
    _routeUpdateTimer?.cancel(); // Nettoyer le timer de routage
    super.dispose();
  }

  Future<void> _initializeApp() async {
    try {
      await _loadDriverData();
      await _initializeLocation();
      await _checkCurrentOrder();
      _startLocationTracking();
      _startRealtimeOrderListening();

      setState(() {
        _isLoading = false;
      });
    } catch (e) {
      print('Erreur initialisation: $e');
      setState(() {
        _isLoading = false;
      });
    }
  }

  Future<void> _loadDriverData() async {
    try {
      _currentDriver = await SessionService.getCurrentDriver();
      if (_currentDriver == null && mounted) {
        Navigator.of(context).pushReplacementNamed('/login');
      }
    } catch (e) {
      print('Erreur chargement driver: $e');
    }
  }

  Future<void> _initializeLocation() async {
    try {
      final hasPermission = await LocationService.checkLocationPermission();
      if (!hasPermission) {
        await LocationService.checkLocationPermission();
      }

      _currentPosition = await LocationService.getCurrentPosition();
      print(
        'üìç Position initiale: ${_currentPosition?.latitude}, ${_currentPosition?.longitude}',
      );
    } catch (e) {
      print('Erreur g√©olocalisation: $e');
    }
  }

  Future<void> _checkCurrentOrder() async {
    if (_currentDriver == null) return;

    try {
      // V√©rifier le statut du livreur dans la DB
      final driverResponse = await Supabase.instance.client
          .from('drivers')
          .select('is_available')
          .eq('id', _currentDriver!.id)
          .single();

      if (driverResponse != null) {
        setState(() {
          _isDriverAvailable = driverResponse['is_available'] ?? true;
        });
      }

      // V√©rifier s'il y a une commande en cours
      final currentOrder = await OrderService.getCurrentDriverOrder(
        _currentDriver!.id,
      );
      if (currentOrder != null && mounted) {
        setState(() {
          _currentOrder = currentOrder;
          _isOnDelivery = true;
        });
        print('üì¶ Commande en cours: ${currentOrder.id}');

        // üéØ RESTAURER LE MARQUEUR CLIENT ET LE MODE CONDUITE
        if (currentOrder.deliveryLat != null &&
            currentOrder.deliveryLng != null) {
          print('üîÑ Restauration du marqueur client et du mode conduite...');
          // Attendre que la carte soit pr√™te
          Future.delayed(const Duration(milliseconds: 1000), () {
            if (_mapController != null) {
              _addClientMarker(
                currentOrder.deliveryLat!,
                currentOrder.deliveryLng!,
              );
              _activateDrivingMode(
                currentOrder.deliveryLat!,
                currentOrder.deliveryLng!,
              );
              print('‚úÖ Marqueur client et mode conduite restaur√©s');
            }
          });
        }
      }
    } catch (e) {
      print('Erreur v√©rification commande actuelle: $e');
    }
  }

  void _startLocationTracking() {
    _locationTimer = Timer.periodic(const Duration(seconds: 10), (timer) async {
      try {
        final newPosition = await LocationService.getCurrentPosition();
        if (newPosition != null && mounted) {
          setState(() => _currentPosition = newPosition);
          _updateMapLocation();
          await _updateDriverLocationInDB();
        }
      } catch (e) {
        print('Erreur tracking position: $e');
      }
    });
  }

  // M√©thode de test pour v√©rifier les commandes disponibles
  Future<void> _testCheckOrders() async {
    try {
      print('üß™ Test: V√©rification des commandes disponibles...');
      final orders = await OrderService.getReadyOrdersTest();
      print('üß™ Test: ${orders.length} commandes trouv√©es');

      if (orders.isNotEmpty) {
        for (final order in orders) {
          print(
            'üß™ Test: Commande #${order.id} - ${order.customerName} - ${order.deliveryAddress}',
          );
        }

        if (_isDriverAvailable && !_isOnDelivery) {
          setState(() {
            _availableOrders = orders;
          });
          _showNotificationModal();
        }
      }
    } catch (e) {
      print('üß™ Test: Erreur lors de la v√©rification: $e');
    }
  }

  void _startRealtimeOrderListening() {
    if (_currentDriver == null) {
      print('‚ùå Pas de driver connect√©, impossible d\'√©couter les commandes');
      return;
    }

    print(
      'üîî D√©marrage de l\'√©coute des commandes temps r√©el pour le driver ${_currentDriver!.id}',
    );

    // Diagnostic Realtime
    RealtimeDebugService.testRealtimeConnection();

    // TEMPORAIRE: Utiliser un timer au lieu de Realtime
    _notificationTimer = Timer.periodic(const Duration(seconds: 5), (
      timer,
    ) async {
      if (_isDriverAvailable && !_isOnDelivery && !_isModalOpen) {
        await _testCheckOrders();
      }
    });

    // √âcouter les nouvelles commandes en temps r√©el (si Realtime est configur√©)
    _ordersSubscription = OrderService.listenToReadyOrders().listen(
      (orders) {
        print('üì¶ Commandes re√ßues: ${orders.length} commandes disponibles');
        print(
          'üîç Driver disponible: $_isDriverAvailable, En livraison: $_isOnDelivery',
        );

        if (mounted && _isDriverAvailable && !_isOnDelivery && !_isModalOpen) {
          setState(() {
            _availableOrders = orders;
          });

          if (orders.isNotEmpty) {
            print('üö® Affichage du modal avec ${orders.length} commandes');
            _showNotificationModal();
          } else {
            print('üì≠ Aucune commande disponible');
          }
        } else {
          print(
            '‚è∏Ô∏è Modal non affich√© - Driver indisponible, en livraison ou modal d√©j√† ouvert',
          );
        }
      },
      onError: (error) {
        print('‚ùå Erreur √©coute commandes: $error');
      },
    );
  }

  Future<void> _updateDriverLocationInDB() async {
    if (_currentPosition != null && _currentDriver != null) {
      try {
        await Supabase.instance.client
            .from('drivers')
            .update({
              'current_lat': _currentPosition!.latitude,
              'current_lng': _currentPosition!.longitude,
              'updated_at': DateTime.now().toIso8601String(),
            })
            .eq('id', _currentDriver!.id);

        print(
          'üìç Position mise √† jour en DB: ${_currentPosition!.latitude}, ${_currentPosition!.longitude}',
        );
      } catch (e) {
        print('Erreur mise √† jour DB: $e');
      }
    }
  }

  Future<void> _onMapCreated(GoogleMapController controller) async {
    try {
      _mapController = controller;

      // üéØ CHARGER LES IMAGES UNE SEULE FOIS AU D√âMARRAGE
      await _loadMarkerIcons();

      print('‚úÖ Images des marqueurs charg√©es');

      _updateMapLocation();

      // üîÑ RESTAURER LE MODE CONDUITE APR√àS HOT RESTART
      if (_isOnDelivery &&
          _currentOrder != null &&
          _currentOrder!.deliveryLat != null &&
          _currentOrder!.deliveryLng != null) {
        print('üîÑ Restauration du mode conduite apr√®s hot restart...');
        Future.delayed(const Duration(milliseconds: 500), () {
          _addClientMarker(
            _currentOrder!.deliveryLat!,
            _currentOrder!.deliveryLng!,
          );
          _activateDrivingMode(
            _currentOrder!.deliveryLat!,
            _currentOrder!.deliveryLng!,
          );
          print('‚úÖ Mode conduite restaur√© apr√®s hot restart');
        });
      }
    } catch (e) {
      print('Erreur cr√©ation carte: $e');
    }
  }

  Future<void> _loadMarkerIcons() async {
    try {
      // Cr√©er des cercles color√©s simples
      _driverMarkerIcon = await DirectionalMarker.createSimpleMarker(
        color: Colors.blue,
        size: 40.0,
      );

      _clientMarkerIcon = await DirectionalMarker.createSimpleMarker(
        color: Colors.yellow,
        size: 40.0,
      );

      print('‚úÖ Marqueurs (cercles color√©s) cr√©√©s avec succ√®s');
    } catch (e) {
      print(
        '‚ö†Ô∏è Erreur cr√©ation markers, utilisation des markers par d√©faut: $e',
      );
      _driverMarkerIcon = BitmapDescriptor.defaultMarkerWithHue(
        BitmapDescriptor.hueBlue,
      );
      _clientMarkerIcon = BitmapDescriptor.defaultMarkerWithHue(
        BitmapDescriptor.hueGreen,
      );
    }
  }

  void _updateMapLocation() async {
    if (_mapController != null && _currentPosition != null) {
      try {
        // üîç Zoom adaptatif selon le mode
        double zoom = 15.0;
        if (_isDrivingMode && _currentOrder != null) {
          // En mode conduite, utiliser le zoom adaptatif
          final distance = geo.Geolocator.distanceBetween(
            _currentPosition!.latitude,
            _currentPosition!.longitude,
            _currentOrder!.deliveryLat!,
            _currentOrder!.deliveryLng!,
          );

          if (distance > 10000) zoom = 11.0;
          if (distance > 5000) zoom = 12.0;
          if (distance > 2000) zoom = 13.0;
          if (distance < 500) zoom = 16.0;
          if (distance < 100) zoom = 18.0;
        }

        await _mapController!.animateCamera(
          CameraUpdate.newLatLngZoom(
            LatLng(_currentPosition!.latitude, _currentPosition!.longitude),
            zoom,
          ),
        );

        // Calculer le bearing si on a une position pr√©c√©dente
        if (_previousPosition != null) {
          final distance = geo.Geolocator.distanceBetween(
            _previousPosition!.latitude,
            _previousPosition!.longitude,
            _currentPosition!.latitude,
            _currentPosition!.longitude,
          );

          // Ne calculer le bearing que si le livreur s'est d√©plac√© d'au moins 10 m√®tres
          // Cela √©vite que le marqueur bouge quand on est stationn√©
          if (distance >= 10.0) {
            _currentBearing = geo.Geolocator.bearingBetween(
              _previousPosition!.latitude,
              _previousPosition!.longitude,
              _currentPosition!.latitude,
              _currentPosition!.longitude,
            );
            // Normaliser √† 0-360
            if (_currentBearing! < 0) {
              _currentBearing = _currentBearing! + 360;
            }
          }
          // Sinon, garder le bearing pr√©c√©dent pour √©viter les mouvements erratiques
        }

        // ‚úÖ Supprimer uniquement l'ancien marker du livreur (PAS le client)
        _markers.removeWhere((m) => m.markerId == const MarkerId('driver'));

        // Cr√©er le marqueur directionnel avec halo (sans popup)
        // Utiliser le bearing pr√©c√©dent si on est stationn√©
        final bearing = _currentBearing ?? 0.0;
        final directionalIcon = await DirectionalMarker.createDirectionalMarker(
          color: Colors.blue,
          bearing: bearing,
          showPopup: false,
        );

        // Ajouter le marker du livreur
        final driverMarker = Marker(
          markerId: const MarkerId('driver'),
          position: LatLng(
            _currentPosition!.latitude,
            _currentPosition!.longitude,
          ),
          icon: directionalIcon,
          anchor: const Offset(
            0.5,
            0.5,
          ), // Ancrage au centre pour le marqueur directionnel
        );

        // Mettre √† jour la position pr√©c√©dente
        _previousPosition = _currentPosition;

        setState(() {
          _markers.add(driverMarker);
        });

        print('üìç Marker livreur mis √† jour (client pr√©serv√©)');
      } catch (e) {
        print('Erreur mise √† jour carte: $e');
      }
    }
  }

  void _showNotificationModal() {
    _isModalOpen = true; // Marquer le modal comme ouvert
    print('üö® Ouverture du modal de notification');
    showModalBottomSheet(
      context: context,
      isScrollControlled: true,
      backgroundColor: Colors.transparent,
      isDismissible: true, // Permettre la fermeture par tap
      enableDrag: true, // Permettre la fermeture par glissement
      builder: (context) => MultiOrderNotificationModal(
        orders: _availableOrders,
        onAccept: _acceptOrder,
        onDecline: _declineOrder,
        onClose: _closeNotificationModal,
      ),
    ).then((_) {
      // Callback appel√© quand le modal se ferme
      _isModalOpen = false;
      print('üîí Modal ferm√© via callback');
    });
  }

  Future<void> _acceptOrder(String orderId) async {
    if (_currentDriver == null) return;

    // V√©rifier si on est d√©j√† en train de traiter cette commande
    if (_isOnDelivery) {
      print(
        '‚ö†Ô∏è D√©j√† en livraison, impossible d\'accepter une nouvelle commande',
      );
      return;
    }

    try {
      print('‚úÖ Acceptation de la commande $orderId');
      final orderIdInt = int.parse(orderId);
      final success = await OrderService.acceptOrder(
        orderIdInt,
        _currentDriver!.id,
      );

      if (success) {
        final order = _availableOrders.firstWhere((o) => o.id == orderIdInt);

        // Fermer le modal AVANT de mettre √† jour l'√©tat
        _closeNotificationModal();

        setState(() {
          _currentOrder = order;
          _isOnDelivery = true;
          _isDriverAvailable =
              true; // Rester disponible pour voir la position du client
          _availableOrders.clear();
        });

        // Afficher la position de livraison sur la carte
        if (order.deliveryLat != null && order.deliveryLng != null) {
          print(
            'üìç Affichage position client: ${order.deliveryLat}, ${order.deliveryLng}',
          );
          _showDeliveryLocation(order.deliveryLat!, order.deliveryLng!);
        } else {
          print(
            '‚ùå Coordonn√©es de livraison manquantes: lat=${order.deliveryLat}, lng=${order.deliveryLng}',
          );
        }

        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Commande #$orderId accept√©e !'),
            backgroundColor: AppColors.successColor,
          ),
        );

        print('‚úÖ Commande accept√©e: $orderId');
      } else {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Commande d√©j√† accept√©e par un autre livreur'),
            backgroundColor: AppColors.errorColor,
          ),
        );
      }
    } catch (e) {
      print('Erreur acceptation commande: $e');
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text('Erreur lors de l\'acceptation'),
          backgroundColor: AppColors.errorColor,
        ),
      );
    }
  }

  Future<void> _declineOrder(String orderId) async {
    try {
      setState(() {
        _availableOrders.removeWhere((o) => o.id.toString() == orderId);
      });

      if (_availableOrders.isEmpty) {
        _closeNotificationModal();
      }

      print('‚ùå Commande refus√©e: $orderId');
    } catch (e) {
      print('Erreur refus commande: $e');
    }
  }

  void _closeNotificationModal() {
    _isModalOpen = false; // Marquer le modal comme ferm√©
    print('üîí Fermeture du modal de notification');

    // Essayer plusieurs m√©thodes pour fermer le modal
    if (Navigator.of(context).canPop()) {
      Navigator.of(context).pop();
      print('‚úÖ Modal ferm√© avec Navigator.pop()');
    } else {
      print('‚ö†Ô∏è Impossible de fermer le modal avec Navigator.pop()');
    }

    // Nettoyer la liste des commandes disponibles
    setState(() {
      _availableOrders.clear();
    });
  }

  void _showDeliveryLocation(double lat, double lng) {
    print('üéØ _showDeliveryLocation appel√© avec: lat=$lat, lng=$lng');
    print('üìç Coordonn√©es pour Google Maps: LatLng($lat, $lng)');
    print('üåç V√©rification: Ces coordonn√©es sont-elles en C√¥te d\'Ivoire ?');

    if (_mapController != null) {
      print('üó∫Ô∏è Carte disponible, centrage sur la position client');
      // Centrer la carte sur la position de livraison
      _mapController!.animateCamera(
        CameraUpdate.newLatLngZoom(LatLng(lat, lng), 15.0),
      );

      // Ajouter un marqueur jaune pour la destination du client
      _addClientMarker(lat, lng);

      // üöó ACTIVER LE MODE CONDUITE
      _activateDrivingMode(lat, lng);
    } else {
      print('‚ùå Carte non disponible');
    }
  }

  void _addClientMarker(double lat, double lng) async {
    print('üü° _addClientMarker appel√© avec: $lat, $lng');
    if (_mapController == null) {
      print('‚ùå GoogleMapController non disponible');
      return;
    }

    try {
      // Supprimer l'ancien marqueur client s'il existe
      _markers.removeWhere((m) => m.markerId == const MarkerId('client'));

      // S'assurer que l'ic√¥ne est charg√©e
      if (_clientMarkerIcon == null) {
        await _loadMarkerIcons();
      }

      // Cr√©er le nouveau marqueur client
      final clientMarker = Marker(
        markerId: const MarkerId('client'),
        position: LatLng(lat, lng),
        icon:
            _clientMarkerIcon ??
            BitmapDescriptor.defaultMarkerWithHue(BitmapDescriptor.hueGreen),
        anchor: const Offset(0.5, 1.0),
      );

      setState(() {
        _markers.add(clientMarker);
      });

      print('‚úÖ Marqueur client ajout√© √† la position: $lat, $lng');
    } catch (e) {
      print('‚ùå Erreur ajout marqueur client: $e');
    }
  }

  /// üöó Active le mode conduite avec trac√© directionnel
  void _activateDrivingMode(double clientLat, double clientLng) {
    setState(() {
      _isDrivingMode = true;
    });

    print('üöó Mode conduite activ√©');

    // Calculer et afficher l'itin√©raire
    _calculateAndDisplayRoute(clientLat, clientLng);

    // D√©marrer la mise √† jour p√©riodique de l'itin√©raire
    _startRouteUpdateTimer(clientLat, clientLng);

    // Zoom adaptatif pour la conduite
    _setDrivingZoom();
  }

  /// üó∫Ô∏è Calcule et affiche l'itin√©raire entre le livreur et le client
  Future<void> _calculateAndDisplayRoute(
    double clientLat,
    double clientLng,
  ) async {
    if (_currentPosition == null) {
      print('‚ùå Position du livreur non disponible pour calculer l\'itin√©raire');
      return;
    }

    try {
      print('üó∫Ô∏è Calcul de l\'itin√©raire Google Maps en cours...');
      print(
        'üìç Position livreur: ${_currentPosition!.latitude}, ${_currentPosition!.longitude}',
      );
      print('üìç Position client: $clientLat, $clientLng');

      // Utiliser le service de routage Google Maps
      final route = await GoogleMapsRoutingService.getRoute(
        startLat: _currentPosition!.latitude,
        startLng: _currentPosition!.longitude,
        endLat: clientLat,
        endLng: clientLng,
      );

      if (route != null) {
        setState(() {
          _currentRoute = route;
        });

        // Afficher l'itin√©raire sur la carte
        await _drawRoute(route.coordinates);

        // Centrer la carte sur l'itin√©raire complet
        await _centerMapOnRoute(route.coordinates);

        print(
          '‚úÖ Itin√©raire affich√©: ${route.formattedDistance} ‚Ä¢ ${route.formattedDuration}',
        );
      } else {
        print('‚ùå Impossible de calculer l\'itin√©raire');
        // Fallback: ligne droite
        await _drawFallbackRoute(clientLat, clientLng);
      }
    } catch (e) {
      print('‚ùå Erreur calcul itin√©raire: $e');
      // Fallback: ligne droite
      await _drawFallbackRoute(clientLat, clientLng);
    }
  }

  /// üõ£Ô∏è Fallback: ligne droite si le routage √©choue
  Future<void> _drawFallbackRoute(double clientLat, double clientLng) async {
    if (_currentPosition == null) return;

    final fallbackRoute = [
      LatLng(_currentPosition!.latitude, _currentPosition!.longitude),
      LatLng(clientLat, clientLng),
    ];

    await _drawRoute(fallbackRoute);
    print('‚ö†Ô∏è Utilisation de l\'itin√©raire de secours (ligne droite)');
  }

  /// üéØ Centre la carte sur l'itin√©raire complet
  Future<void> _centerMapOnRoute(List<LatLng> coordinates) async {
    if (_mapController == null || coordinates.isEmpty) return;

    try {
      // Calculer les limites de l'itin√©raire
      double minLat = coordinates.first.latitude;
      double maxLat = coordinates.first.latitude;
      double minLng = coordinates.first.longitude;
      double maxLng = coordinates.first.longitude;

      for (final coord in coordinates) {
        minLat = minLat < coord.latitude ? minLat : coord.latitude;
        maxLat = maxLat > coord.latitude ? maxLat : coord.latitude;
        minLng = minLng < coord.longitude ? minLng : coord.longitude;
        maxLng = maxLng > coord.longitude ? maxLng : coord.longitude;
      }

      // Centrer la carte sur l'itin√©raire avec animation
      // Calculer le centre de l'itin√©raire
      final centerLat = (minLat + maxLat) / 2;
      final centerLng = (minLng + maxLng) / 2;

      // Calculer le zoom pour encadrer l'itin√©raire
      final latDiff = maxLat - minLat;
      final lngDiff = maxLng - minLng;
      final maxDiff = latDiff > lngDiff ? latDiff : lngDiff;

      double zoom = 15.0;
      if (maxDiff > 0.1) zoom = 10.0;
      if (maxDiff > 0.05) zoom = 12.0;
      if (maxDiff > 0.01) zoom = 14.0;

      await _mapController!.animateCamera(
        CameraUpdate.newCameraPosition(
          CameraPosition(target: LatLng(centerLat, centerLng), zoom: zoom),
        ),
      );

      print('üéØ Carte centr√©e sur l\'itin√©raire');
    } catch (e) {
      print('‚ùå Erreur centrage carte: $e');
    }
  }

  /// üé® Dessine la polyline de l'itin√©raire sur la carte
  Future<void> _drawRoute(List<LatLng> coordinates) async {
    if (_mapController == null) return;

    try {
      print('üé® Dessin de la polyline avec ${coordinates.length} points');
      if (coordinates.isNotEmpty) {
        print(
          'üìç Premier point: ${coordinates.first.latitude}, ${coordinates.first.longitude}',
        );
        print(
          'üìç Dernier point: ${coordinates.last.latitude}, ${coordinates.last.longitude}',
        );
      }

      // Supprimer l'ancienne polyline
      _polylines.removeWhere((p) => p.polylineId == const PolylineId('route'));

      // Cr√©er la nouvelle polyline avec geodesic pour suivre la route r√©elle
      final routePolyline = Polyline(
        polylineId: const PolylineId('route'),
        points: coordinates,
        color: AppColors.primaryRed,
        width: 5,
        geodesic:
            true, // Suivre la courbure de la Terre pour une route plus r√©aliste
      );

      setState(() {
        _polylines.add(routePolyline);
      });

      print('‚úÖ Polyline de l\'itin√©raire dessin√©e');
    } catch (e) {
      print('‚ùå Erreur dessin polyline: $e');
    }
  }

  /// ‚è∞ D√©marre le timer de mise √† jour de l'itin√©raire
  void _startRouteUpdateTimer(double clientLat, double clientLng) {
    _routeUpdateTimer?.cancel();

    _routeUpdateTimer = Timer.periodic(const Duration(seconds: 30), (
      timer,
    ) async {
      if (_currentPosition != null && _isOnDelivery && _isDrivingMode) {
        print('üîÑ Mise √† jour de l\'itin√©raire...');
        await _calculateAndDisplayRoute(clientLat, clientLng);
      } else {
        timer.cancel();
        print('‚èπÔ∏è Arr√™t de la mise √† jour de l\'itin√©raire');
      }
    });
  }

  /// üîç Zoom adaptatif pour le mode conduite avec animation visible
  void _setDrivingZoom() {
    if (_mapController == null ||
        _currentPosition == null ||
        _currentOrder == null)
      return;

    // Calculer la distance entre le livreur et le client
    final distance = geo.Geolocator.distanceBetween(
      _currentPosition!.latitude,
      _currentPosition!.longitude,
      _currentOrder!.deliveryLat!,
      _currentOrder!.deliveryLng!,
    );

    // Zoom adaptatif selon la distance
    double zoom = 15.0;
    if (distance > 10000)
      zoom = 11.0; // Vue tr√®s large pour tr√®s longues distances
    if (distance > 5000) zoom = 12.0; // Vue large pour longues distances
    if (distance > 2000) zoom = 13.0; // Vue moyenne
    if (distance < 500) zoom = 16.0; // Vue rapproch√©e pour arriv√©e
    if (distance < 100) zoom = 18.0; // Vue tr√®s rapproch√©e pour arriv√©e

    _mapController!.animateCamera(
      CameraUpdate.newLatLngZoom(
        LatLng(_currentPosition!.latitude, _currentPosition!.longitude),
        zoom,
      ),
    );

    print(
      'üîç Zoom adaptatif: $zoom (distance: ${distance.toStringAsFixed(0)}m)',
    );
  }

  /// üóëÔ∏è Supprime l'itin√©raire de la carte
  Future<void> _clearRoute() async {
    _polylines.removeWhere((p) => p.polylineId == const PolylineId('route'));

    _routeUpdateTimer?.cancel();
    _routeUpdateTimer = null;

    setState(() {
      _isDrivingMode = false;
    });

    print('üóëÔ∏è Itin√©raire supprim√© de la carte');
  }

  // M√©thodes supprim√©es - les markers sont maintenant charg√©s via _loadMarkerIcons()

  /// ‚úÖ Finalise une livraison avec code de confirmation
  Future<void> _completeDelivery() async {
    if (_currentOrder == null) return;

    try {
      print(
        '‚úÖ Finalisation de la livraison de la commande ${_currentOrder!.id}',
      );

      // Afficher le modal de saisie du code
      _showDeliveryCodeModal();
    } catch (e) {
      print('‚ùå Erreur finalisation livraison: $e');
      _showErrorSnackBar('Erreur lors de la finalisation de la livraison');
    }
  }

  /// üîê Affiche le modal de saisie du code de livraison
  void _showDeliveryCodeModal() {
    showDialog(
      context: context,
      barrierDismissible: false,
      builder: (context) => DeliveryCodeModal(
        orderId: _currentOrder!.id.toString(),
        customerName: _currentOrder!.customerName ?? 'Client',
        onConfirm: _handleDeliveryCodeConfirmation,
        onCancel: () {
          Navigator.of(context).pop();
        },
      ),
    );
  }

  /// ‚úÖ Traite la confirmation du code de livraison
  Future<void> _handleDeliveryCodeConfirmation(String code) async {
    if (_currentOrder == null) return;

    try {
      print('üîê Validation du code de livraison: $code');

      // Valider le code avec Supabase
      final isValid = await DeliveryCodeService.validateDeliveryCode(
        _currentOrder!.id,
        code,
      );

      if (!isValid) {
        _showErrorSnackBar('Code de livraison invalide ou expir√©');
        return;
      }

      // Confirmer la livraison
      final isConfirmed = await DeliveryCodeService.confirmDelivery(
        _currentOrder!.id,
        code,
        'driver_${_currentDriver!.id}',
      );

      if (!isConfirmed) {
        _showErrorSnackBar('Erreur lors de la confirmation de la livraison');
        return;
      }

      // Fermer le modal
      Navigator.of(context).pop();

      // Finaliser la livraison dans l'app
      await _finalizeDelivery();
    } catch (e) {
      print('‚ùå Erreur confirmation code: $e');
      _showErrorSnackBar('Erreur lors de la validation du code');
    }
  }

  /// üéØ Finalise la livraison apr√®s confirmation du code
  Future<void> _finalizeDelivery() async {
    try {
      // Marquer la livraison comme termin√©e dans order_driver_assignments
      await OrderService.completeDelivery(_currentOrder!.id);

      // Nettoyer l'√©tat de l'app
      setState(() {
        _currentOrder = null;
        _isOnDelivery = false;
        _isDriverAvailable = true;
        _isDeliveryCardVisible = true;
      });

      // Supprimer le marqueur client
      _markers.removeWhere((m) => m.markerId == const MarkerId('client'));

      // Nettoyer l'itin√©raire
      await _clearRoute();

      // Afficher le message de succ√®s
      _showSuccessSnackBar('Livraison confirm√©e avec succ√®s !');

      print('‚úÖ Livraison finalis√©e avec succ√®s');
    } catch (e) {
      print('‚ùå Erreur finalisation: $e');
      _showErrorSnackBar('Erreur lors de la finalisation');
    }
  }

  /// üì± Affiche un message d'erreur
  void _showErrorSnackBar(String message) {
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(
        content: Text(message),
        backgroundColor: Colors.red,
        duration: const Duration(seconds: 3),
      ),
    );
  }

  /// ‚úÖ Affiche un message de succ√®s
  void _showSuccessSnackBar(String message) {
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(
        content: Text(message),
        backgroundColor: Colors.green,
        duration: const Duration(seconds: 3),
      ),
    );
  }

  void _toggleDriverStatus(bool isAvailable) async {
    setState(() {
      _isDriverAvailable = isAvailable;
    });

    // Mettre √† jour le statut dans la base de donn√©es
    if (_currentDriver != null) {
      try {
        await Supabase.instance.client
            .from('drivers')
            .update({
              'is_available': isAvailable,
              'updated_at': DateTime.now().toIso8601String(),
            })
            .eq('id', _currentDriver!.id);

        print(
          'üì± Statut livreur mis √† jour: ${isAvailable ? "Disponible" : "Indisponible"}',
        );
      } catch (e) {
        print('Erreur mise √† jour statut: $e');
      }
    }

    // Si on passe en mode indisponible et qu'on a une commande en cours, la garder
    if (!isAvailable && _isOnDelivery) {
      // Le livreur reste en livraison m√™me s'il passe en indisponible
      return;
    }

    // Fermer le modal de notifications si on passe en indisponible
    if (!isAvailable && Navigator.of(context).canPop()) {
      _closeNotificationModal();
    }
  }

  @override
  Widget build(BuildContext context) {
    final themeService = Provider.of<ThemeService>(context);

    if (_isLoading) {
      return Scaffold(
        backgroundColor: themeService.getMapBackgroundColor(),
        body: Center(
          child: CircularProgressIndicator(color: AppColors.primaryRed),
        ),
      );
    }

    return Scaffold(
      backgroundColor: const Color(0xFFF7F7F9), // Fond gris clair fixe
      body: Stack(
        children: [
          // CARTE PLEIN √âCRAN
          GoogleMap(
            initialCameraPosition: CameraPosition(
              target: LatLng(
                _currentPosition?.latitude ?? 5.3599,
                _currentPosition?.longitude ?? -4.0083,
              ),
              zoom: 15.0,
            ),
            onMapCreated: _onMapCreated,
            mapType: MapType.normal,
            markers: _markers,
            polylines: _polylines,
            myLocationEnabled:
                false, // D√©sactiv√© pour √©viter le doublon avec notre marqueur personnalis√©
            myLocationButtonEnabled: false,
            zoomGesturesEnabled: true,
            scrollGesturesEnabled: true,
            rotateGesturesEnabled: true,
            tiltGesturesEnabled: true,
          ),

          // OVERLAY MODE INDISPONIBLE
          if (!_isDriverAvailable)
            Container(
              color: Colors.black.withOpacity(0.7),
              child: Center(
                child: Column(
                  mainAxisAlignment: MainAxisAlignment.center,
                  children: [
                    Icon(
                      Icons.pause_circle_outline,
                      size: 80,
                      color: Colors.white.withOpacity(0.8),
                    ),
                    const SizedBox(height: 20),
                    Text(
                      'Mode Indisponible',
                      style: GoogleFonts.poppins(
                        fontSize: 24,
                        fontWeight: FontWeight.bold,
                        color: Colors.white,
                      ),
                    ),
                    const SizedBox(height: 10),
                    Text(
                      'Vous ne recevrez pas de nouvelles commandes',
                      style: GoogleFonts.poppins(
                        fontSize: 16,
                        color: Colors.white.withOpacity(0.8),
                      ),
                      textAlign: TextAlign.center,
                    ),
                  ],
                ),
              ),
            ),

          // HEADER
          _buildHeader(themeService),

          // STATUS PANEL
          _buildStatusPanel(themeService),

          // NAVIGATION PANEL (si en mode conduite)
          if (_isDrivingMode && _currentRoute != null) _buildNavigationPanel(),

          // DELIVERY PANEL (si en livraison)
          if (_isOnDelivery && _currentOrder != null) _buildDeliveryPanel(),

          // BOTTOM NAVIGATION
          _buildBottomNavigation(themeService),

          // BOUTON FLOTTANT POSITION ACTUELLE
          _buildCurrentLocationButton(),
        ],
      ),
    );
  }

  Widget _buildHeader(ThemeService themeService) {
    return Positioned(
      top: 0,
      left: 0,
      right: 0,
      child: Container(
        height: 120,
        decoration: BoxDecoration(
          color: Colors.white,
          boxShadow: [
            BoxShadow(
              color: Colors.black.withOpacity(0.1),
              blurRadius: 10,
              offset: const Offset(0, 2),
            ),
          ],
        ),
        child: SafeArea(
          child: Padding(
            padding: const EdgeInsets.symmetric(horizontal: 16),
            child: Row(
              children: [
                // Logo ChapFood
                Expanded(flex: 2, child: const ChapFoodLogo()),

                // Actions droite
                Expanded(
                  flex: 1,
                  child: Row(
                    mainAxisSize: MainAxisSize.min,
                    children: [
                      // Badge notifications
                      NotificationBadge(
                        count: _availableOrders.length,
                        onTap: () {
                          if (_availableOrders.isNotEmpty) {
                            _showNotificationModal();
                          }
                        },
                      ),

                      const SizedBox(width: 8),

                      // Bouton mode sombre/clair
                      Consumer<ThemeService>(
                        builder: (context, themeService, child) {
                          return IconButton(
                            onPressed: () {
                              themeService.toggleTheme();
                            },
                            icon: Icon(
                              themeService.isDarkMode
                                  ? Icons.light_mode
                                  : Icons.dark_mode,
                              color: AppColors.primaryRed,
                            ),
                            style: IconButton.styleFrom(
                              backgroundColor: AppColors.primaryRed.withOpacity(
                                0.1,
                              ),
                              shape: const CircleBorder(),
                            ),
                          );
                        },
                      ),
                    ],
                  ),
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }

  /// üß≠ Panneau d'informations de navigation
  Widget _buildNavigationPanel() {
    if (_currentRoute == null) return const SizedBox.shrink();

    return Positioned(
      top: 140, // Sous le panneau de statut
      left: 16,
      right: 16,
      child: Container(
        padding: const EdgeInsets.all(16),
        decoration: BoxDecoration(
          color: Colors.white,
          borderRadius: BorderRadius.circular(12),
          boxShadow: [
            BoxShadow(
              color: Colors.black.withOpacity(0.1),
              blurRadius: 10,
              offset: const Offset(0, 4),
            ),
          ],
        ),
        child: Row(
          children: [
            // Ic√¥ne de navigation
            Container(
              width: 40,
              height: 40,
              decoration: BoxDecoration(
                color: AppColors.primaryRed.withOpacity(0.1),
                borderRadius: BorderRadius.circular(20),
              ),
              child: const Icon(
                Icons.navigation,
                color: AppColors.primaryRed,
                size: 20,
              ),
            ),
            const SizedBox(width: 12),

            // Informations de route
            Expanded(
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(
                    'Navigation active',
                    style: AppTextStyles.foodItemTitle.copyWith(fontSize: 16),
                  ),
                  const SizedBox(height: 4),
                  Row(
                    children: [
                      Icon(Icons.route, size: 14, color: Colors.grey[600]),
                      const SizedBox(width: 4),
                      Text(
                        _currentRoute!.formattedDistance,
                        style: AppTextStyles.foodItemDescription.copyWith(
                          fontWeight: FontWeight.w600,
                        ),
                      ),
                      const SizedBox(width: 12),
                      Icon(
                        Icons.access_time,
                        size: 14,
                        color: Colors.grey[600],
                      ),
                      const SizedBox(width: 4),
                      Text(
                        _currentRoute!.formattedDuration,
                        style: AppTextStyles.foodItemDescription.copyWith(
                          fontWeight: FontWeight.w600,
                        ),
                      ),
                    ],
                  ),
                ],
              ),
            ),

            // Bouton pour d√©sactiver le mode conduite
            IconButton(
              onPressed: () {
                setState(() {
                  _isDrivingMode = false;
                });
                _clearRoute();
              },
              icon: const Icon(
                Icons.close,
                color: AppColors.primaryRed,
                size: 20,
              ),
              tooltip: 'D√©sactiver la navigation',
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildStatusPanel(ThemeService themeService) {
    return Positioned(
      top: 140,
      left: 16,
      right: 16,
      child: AnimatedContainer(
        duration: const Duration(milliseconds: 300),
        decoration: BoxDecoration(
          color: Colors.white,
          borderRadius: BorderRadius.circular(16),
          boxShadow: [
            BoxShadow(
              color: Colors.black.withOpacity(0.1),
              blurRadius: 20,
              offset: const Offset(0, 4),
            ),
          ],
        ),
        child: _isOnDelivery
            ? _buildCompactStatusPanel()
            : _buildFullStatusPanel(),
      ),
    );
  }

  Widget _buildCompactStatusPanel() {
    return Container(
      padding: const EdgeInsets.all(16),
      child: Row(
        children: [
          Container(
            padding: const EdgeInsets.all(8),
            decoration: BoxDecoration(
              color: AppColors.primaryRed.withOpacity(0.1),
              borderRadius: BorderRadius.circular(8),
            ),
            child: const Icon(
              Icons.delivery_dining,
              color: AppColors.primaryRed,
              size: 20,
            ),
          ),
          const SizedBox(width: 12),

          Expanded(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  'Livraison en cours',
                  style: GoogleFonts.poppins(
                    fontSize: 16,
                    fontWeight: FontWeight.w600,
                    color: Colors.black,
                  ),
                ),
                Text(
                  'Commande #${_currentOrder?.id}',
                  style: GoogleFonts.poppins(
                    fontSize: 12,
                    color: Colors.grey[600],
                  ),
                ),
              ],
            ),
          ),

          // Bouton pour masquer/d√©masquer le card de d√©tails
          IconButton(
            onPressed: () {
              print(
                'üîÑ Bouton cliqu√©: _isDeliveryCardVisible = $_isDeliveryCardVisible',
              );
              setState(() {
                _isDeliveryCardVisible = !_isDeliveryCardVisible;
              });
              print(
                'üîÑ Apr√®s clic: _isDeliveryCardVisible = $_isDeliveryCardVisible',
              );
            },
            icon: Icon(
              _isDeliveryCardVisible
                  ? Icons.keyboard_arrow_down
                  : Icons.keyboard_arrow_up,
              color: AppColors.primaryRed,
            ),
            style: IconButton.styleFrom(
              backgroundColor: AppColors.primaryRed.withOpacity(0.1),
              shape: const CircleBorder(),
            ),
            tooltip: _isDeliveryCardVisible
                ? 'Masquer les d√©tails'
                : 'Voir les d√©tails',
          ),
        ],
      ),
    );
  }

  Widget _buildFullStatusPanel() {
    return Column(
      children: [
        DriverStatusToggle(
          isAvailable: _isDriverAvailable,
          onToggle: _toggleDriverStatus,
        ),

        Padding(
          padding: const EdgeInsets.all(16),
          child: Column(
            children: [
              Text(
                _currentDriver?.name ?? 'Livreur',
                style: GoogleFonts.poppins(
                  fontSize: 18,
                  fontWeight: FontWeight.bold,
                  color: Colors.black,
                ),
              ),
              const SizedBox(height: 4),
              Text(
                _currentDriver?.phone ?? 'T√©l√©phone non disponible',
                style: GoogleFonts.poppins(
                  fontSize: 14,
                  color: Colors.grey[600],
                ),
              ),
              const SizedBox(height: 8),
              Row(
                mainAxisAlignment: MainAxisAlignment.spaceEvenly,
                children: [
                  _buildStatItem(
                    icon: Icons.motorcycle,
                    label: 'V√©hicule',
                    value: _currentDriver?.vehicleDisplayName ?? 'Non sp√©cifi√©',
                  ),
                  _buildStatItem(
                    icon: Icons.star,
                    label: 'Note',
                    value: _currentDriver?.ratingDisplay ?? 'N/A',
                  ),
                  _buildStatItem(
                    icon: Icons.location_on,
                    label: 'Position',
                    value: _currentPosition != null ? 'Active' : 'Inactive',
                  ),
                ],
              ),
            ],
          ),
        ),
      ],
    );
  }

  Widget _buildStatItem({
    required IconData icon,
    required String label,
    required String value,
  }) {
    return Column(
      children: [
        Icon(icon, color: AppColors.primaryRed, size: 20),
        const SizedBox(height: 4),
        Text(
          label,
          style: GoogleFonts.poppins(fontSize: 10, color: Colors.grey[600]),
        ),
        Text(
          value,
          style: GoogleFonts.poppins(
            fontSize: 12,
            fontWeight: FontWeight.w600,
            color: Colors.black,
          ),
          textAlign: TextAlign.center,
        ),
      ],
    );
  }

  Widget _buildBottomNavigation(ThemeService themeService) {
    return Positioned(
      bottom: 0,
      left: 0,
      right: 0,
      child: Container(
        height: 80,
        decoration: BoxDecoration(
          color: Colors.white,
          boxShadow: [
            BoxShadow(
              color: Colors.black.withOpacity(0.1),
              blurRadius: 10,
              offset: const Offset(0, -2),
            ),
          ],
        ),
        child: Row(
          mainAxisAlignment: MainAxisAlignment.spaceEvenly,
          children: [
            _buildNavItem(icon: Icons.home, label: 'Accueil', isActive: true),
            _buildNavItem(
              icon: Icons.history,
              label: 'Historique',
              isActive: false,
            ),
            GestureDetector(
              onTap: () {
                Navigator.of(context).push(
                  MaterialPageRoute(
                    builder: (context) => const RevenueHistoryScreen(),
                  ),
                );
              },
              child: _buildNavItem(
                icon: Icons.attach_money,
                label: 'Revenus',
                isActive: false,
              ),
            ),
            GestureDetector(
              onTap: () {
                Navigator.of(context).push(
                  MaterialPageRoute(
                    builder: (context) => const ProfileScreen(),
                  ),
                );
              },
              child: _buildNavItem(
                icon: Icons.person,
                label: 'Profil',
                isActive: false,
              ),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildNavItem({
    required IconData icon,
    required String label,
    required bool isActive,
  }) {
    return Column(
      mainAxisAlignment: MainAxisAlignment.center,
      children: [
        Icon(
          icon,
          color: isActive ? AppColors.primaryRed : Colors.grey[400],
          size: 24,
        ),
        const SizedBox(height: 4),
        Text(
          label,
          style: GoogleFonts.poppins(
            fontSize: 12,
            color: isActive ? AppColors.primaryRed : Colors.grey[400],
            fontWeight: isActive ? FontWeight.w600 : FontWeight.normal,
          ),
        ),
      ],
    );
  }

  Widget _buildCurrentLocationButton() {
    return Positioned(
      right: 16,
      bottom: 100,
      child: FloatingActionButton(
        onPressed: _centerOnCurrentLocation,
        backgroundColor: AppColors.primaryRed,
        child: const Icon(Icons.my_location, color: Colors.white),
      ),
    );
  }

  void _centerOnCurrentLocation() {
    if (_mapController != null && _currentPosition != null) {
      _mapController!.animateCamera(
        CameraUpdate.newLatLngZoom(
          LatLng(_currentPosition!.latitude, _currentPosition!.longitude),
          15.0,
        ),
      );
    }
  }

  Widget _buildDeliveryPanel() {
    return Positioned(
      bottom: 100,
      left: 0,
      right: 0,
      child: _isDeliveryCardVisible
          ? DeliveryPanel(
              order: _currentOrder!,
              onCallCustomer: () {
                // L'appel est g√©r√© dans le DeliveryPanel
              },
              onCompleteDelivery: _completeDelivery,
              distance: 2.5, // TODO: Calculer la vraie distance
              estimatedTime: 15, // TODO: Calculer le vrai temps
            )
          : const SizedBox.shrink(), // Widget vide quand masqu√©
    );
  }
}

// Modal pour les notifications de commandes multiples
class MultiOrderNotificationModal extends StatelessWidget {
  final List<OrderModel> orders;
  final Function(String) onAccept;
  final Function(String) onDecline;
  final VoidCallback onClose;

  const MultiOrderNotificationModal({
    super.key,
    required this.orders,
    required this.onAccept,
    required this.onDecline,
    required this.onClose,
  });

  @override
  Widget build(BuildContext context) {
    return Container(
      height: MediaQuery.of(context).size.height * 0.7,
      decoration: const BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.vertical(top: Radius.circular(20)),
      ),
      child: Column(
        children: [
          // Header
          Container(
            padding: const EdgeInsets.all(16),
            decoration: BoxDecoration(
              gradient: AppColors.buttonGradient,
              borderRadius: const BorderRadius.vertical(
                top: Radius.circular(20),
              ),
            ),
            child: Row(
              children: [
                const Icon(
                  Icons.notifications_active,
                  color: Colors.white,
                  size: 24,
                ),
                const SizedBox(width: 12),
                Expanded(
                  child: Text(
                    'Nouvelles commandes disponibles',
                    style: GoogleFonts.poppins(
                      fontSize: 18,
                      fontWeight: FontWeight.bold,
                      color: Colors.white,
                    ),
                  ),
                ),
                IconButton(
                  onPressed: onClose,
                  icon: const Icon(Icons.close, color: Colors.white),
                ),
              ],
            ),
          ),

          // Liste des commandes
          Expanded(
            child: ListView.builder(
              padding: const EdgeInsets.all(16),
              itemCount: orders.length,
              itemBuilder: (context, index) {
                final order = orders[index];
                return OrderNotificationCard(
                  order: order,
                  onAccept: () => onAccept(order.id.toString()),
                  onDecline: () => onDecline(order.id.toString()),
                );
              },
            ),
          ),

          // Bouton refuser tout
          Container(
            padding: const EdgeInsets.all(16),
            child: SizedBox(
              width: double.infinity,
              child: OutlinedButton(
                onPressed: () {
                  for (final order in orders) {
                    onDecline(order.id.toString());
                  }
                  onClose();
                },
                style: OutlinedButton.styleFrom(
                  side: BorderSide(color: Colors.red[300]!),
                  shape: RoundedRectangleBorder(
                    borderRadius: BorderRadius.circular(12),
                  ),
                  padding: const EdgeInsets.symmetric(vertical: 12),
                ),
                child: Text(
                  "Refuser Tout",
                  style: GoogleFonts.poppins(
                    color: Colors.red[400],
                    fontWeight: FontWeight.w600,
                  ),
                ),
              ),
            ),
          ),
        ],
      ),
    );
  }
}
