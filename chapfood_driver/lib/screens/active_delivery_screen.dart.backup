import 'dart:async';
import 'dart:math' as math;
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:go_router/go_router.dart';
import 'package:google_maps_flutter/google_maps_flutter.dart';
import 'package:geolocator/geolocator.dart' as geo;
import 'package:url_launcher/url_launcher.dart';
import '../services/active_delivery_service.dart';
import '../services/session_service.dart';
import '../services/state_persistence_service.dart';
import '../services/driver_location_service.dart';
import '../services/google_maps_routing_service.dart';
import '../services/smooth_movement_service.dart';
import '../models/order_model.dart';
import '../models/active_delivery_state.dart';
import '../models/driver_model.dart';
import '../widgets/delivery/delivery_status_card.dart';
import '../widgets/delivery/delivery_actions_panel.dart';
import '../widgets/delivery/delivery_completion_modal.dart';
import '../widgets/delivery/route_progress_card.dart';
import '../widgets/map/directional_marker.dart';

/// √âcran d√©di√© √† la livraison active avec carte et suivi en temps r√©el
class ActiveDeliveryScreen extends StatefulWidget {
  final OrderModel order;

  const ActiveDeliveryScreen({super.key, required this.order});

  @override
  State<ActiveDeliveryScreen> createState() => _ActiveDeliveryScreenState();
}

class _ActiveDeliveryScreenState extends State<ActiveDeliveryScreen> {
  OrderModel? _currentOrder;
  bool _hasPickedUp = false;
  bool _hasArrived = false;
  bool _isLoading = true;
  StreamSubscription<OrderModel>? _orderSubscription;
  StreamSubscription<geo.Position>? _positionSubscription;
  DriverModel? _currentDriver;

  // √âtat pour la carte
  GoogleMapController? _mapController;
  geo.Position? _currentPosition;
  final Set<Marker> _markers = {};
  final Set<Polyline> _polylines = {};
  BitmapDescriptor? _driverMarkerIcon;
  BitmapDescriptor? _clientMarkerIcon;
  BitmapDescriptor? _restaurantMarkerIcon;
  RouteInfo? _currentRoute;
  Timer? _routeUpdateTimer;

  // Coordonn√©es du restaurant (en dur)
  static const double restaurantLat = 5.226313;
  static const double restaurantLng = -3.768063;

  // Service pour lisser le mouvement du livreur (marker fluide)
  final SmoothMovementService _smoothMovementService = SmoothMovementService();

  // √âtat pour le mode 3D
  bool _is3DMode = true; // Activ√© par d√©faut
  geo.Position?
  _previousPosition; // Position pr√©c√©dente pour calculer le bearing
  double? _currentBearing; // Bearing actuel calcul√©

  @override
  void initState() {
    super.initState();
    _currentOrder = widget.order;
    _initializeDelivery();
  }

  Future<void> _initializeDelivery() async {
    try {
      // Activer automatiquement le mode 3D
      _is3DMode = true;
      _previousPosition = null;
      _currentBearing = null;

      final driver = await SessionService.getCurrentDriver();
      if (driver == null) {
        if (mounted) {
          context.go('/login');
        }
        return;
      }

      setState(() {
        _currentDriver = driver;
      });

      // Charger les informations de l'assignation
      await _loadAssignmentInfo();

      // √âcouter les changements de statut en temps r√©el
      _orderSubscription =
          ActiveDeliveryService.watchActiveDelivery(_currentOrder!.id).listen((
            order,
          ) {
            if (mounted) {
              setState(() {
                _currentOrder = order;
              });
              _loadAssignmentInfo();
            }
          });

      // D√©marrer le suivi GPS
      await DriverLocationService.startLocationTracking(driver.id);

      // Obtenir la position initiale
      final initialPosition = await DriverLocationService.getCurrentPosition();
      if (initialPosition != null) {
        setState(() {
          _currentPosition = initialPosition;
        });
      }

      // S'assurer que la carte est initialis√©e avant d'afficher les marqueurs
      // Si la carte n'est pas encore cr√©√©e, attendre un peu
      if (_mapController == null) {
        await Future.delayed(const Duration(milliseconds: 1000));
      }

      // R√©initialiser les marqueurs et itin√©raires selon l'√©tape actuelle
      if (_mapController != null) {
        if (!_hasPickedUp) {
          // √âtape 1 : Aller au restaurant
          print('üîÑ R√©initialisation : √âtape 1 - Restaurant');
          await _addRestaurantMarker(restaurantLat, restaurantLng);
          if (_currentPosition != null) {
            await _calculateAndDisplayRouteToRestaurant();
          }
        } else {
          // √âtape 2 : Aller au client
          print('üîÑ R√©initialisation : √âtape 2 - Client');
          if (_currentOrder?.deliveryLat != null &&
              _currentOrder?.deliveryLng != null) {
            await _addClientMarker(
              _currentOrder!.deliveryLat!,
              _currentOrder!.deliveryLng!,
            );
            if (_currentPosition != null) {
              await _calculateAndDisplayRouteToClient();
            }
          }
        }
      }

      // Stream brut du GPS
      final rawPositionStream = geo.Geolocator.getPositionStream(
        locationSettings: const geo.LocationSettings(
          accuracy: geo.LocationAccuracy.high,
          distanceFilter: 3, // Mettre √† jour tous les ~3 m√®tres
        ),
      );

      // D√©marrer le service de mouvement fluide
      _smoothMovementService.startSmoothTracking(rawPositionStream);

      // √âcouter les positions FLUIDES pour animer le marker
      _positionSubscription = _smoothMovementService.positionStream.listen(
        (position) {
          if (!mounted) return;

          setState(() {
            _currentPosition = position;
          });

          // Mettre √† jour le marker du livreur (sans saut)
          _updateDriverMarker();

          // Mettre √† jour l'itin√©raire si n√©cessaire selon l'√©tape
          if (!_hasPickedUp) {
            // √âtape 1 : vers le restaurant
            _updateRoute();
          } else if (_currentOrder?.deliveryLat != null &&
              _currentOrder?.deliveryLng != null) {
            // √âtape 2 : vers le client
            _updateRoute();
          }
        },
        onError: (error) {
          print(
            '‚ùå Erreur dans le suivi de position fluide (active_delivery): $error',
          );
        },
      );

      setState(() {
        _isLoading = false;
      });
    } catch (e) {
      print('‚ùå Erreur lors de l\'initialisation: $e');
      if (mounted) {
        setState(() {
          _isLoading = false;
        });
      }
    }
  }

  @override
  void dispose() {
    _orderSubscription?.cancel();
    _positionSubscription?.cancel();
    _routeUpdateTimer?.cancel();
    _smoothMovementService.stopSmoothTracking();
    // Arr√™ter le suivi GPS si n√©cessaire
    if (_currentDriver != null) {
      DriverLocationService.stopLocationTracking();
    }
    super.dispose();
  }

  Future<void> _loadAssignmentInfo() async {
    try {
      final assignment = await ActiveDeliveryService.getAssignmentInfo(
        _currentOrder!.id,
      );

      if (assignment != null && mounted) {
        final wasPickedUp = _hasPickedUp;

        // V√©rifier aussi le statut de la commande dans la DB
        final orderStatus = _currentOrder?.status.value;
        final isPickedUpInDB = orderStatus == 'picked_up';
        final hasPickedUpAt = assignment.pickedUpAt != null;

        // _hasPickedUp doit √™tre true si soit picked_up_at existe, soit le statut est 'picked_up'
        final shouldBePickedUp = hasPickedUpAt || isPickedUpInDB;

        setState(() {
          _hasPickedUp = shouldBePickedUp;
          _hasArrived = assignment.arrivedAt != null;
        });

        print(
          'üìã √âtat assignation : picked_up_at = ${assignment.pickedUpAt}, statut DB = $orderStatus',
        );
        print('üìã _hasPickedUp mis √† jour √† : $shouldBePickedUp');

        // Si on passe de "pas r√©cup√©r√©" √† "r√©cup√©r√©" (m√™me si chang√© par l'admin)
        if (!wasPickedUp && _hasPickedUp && _mapController != null) {
          // Supprimer le marqueur du restaurant
          _markers.removeWhere(
            (m) => m.markerId == const MarkerId('restaurant'),
          );

          // Supprimer le trac√© vers le restaurant
          _polylines.removeWhere(
            (p) => p.polylineId == const PolylineId('route-to-restaurant'),
          );

          // Ajouter le marqueur du client et calculer l'itin√©raire vers le client
          if (_currentOrder!.deliveryLat != null &&
              _currentOrder!.deliveryLng != null) {
            await _addClientMarker(
              _currentOrder!.deliveryLat!,
              _currentOrder!.deliveryLng!,
            );
            await _calculateAndDisplayRouteToClient();
          }
        }
      }
    } catch (e) {
      print('‚ùå Erreur lors du chargement de l\'assignation: $e');
    }
  }

  /// Initialisation de la carte Google Maps
  Future<void> _onMapCreated(GoogleMapController controller) async {
    _mapController = controller;

    // Charger les images de marqueurs
    await _loadMarkerImages();

    // Initialiser les marqueurs et l'itin√©raire
    if (_currentPosition != null) {
      await _updateDriverMarker();
    }

    // Attendre un peu pour s'assurer que _loadAssignmentInfo() a termin√©
    await Future.delayed(const Duration(milliseconds: 500));

    // D√©terminer l'√©tape actuelle
    print('üîç √âtat actuel : _hasPickedUp = $_hasPickedUp');
    print('üîç Statut de la commande : ${_currentOrder?.status.value}');

    // S'assurer que si le statut n'est pas 'picked_up', on est √† l'√©tape 1
    final isPickedUpInDB = _currentOrder?.status.value == 'picked_up';
    if (isPickedUpInDB && !_hasPickedUp) {
      print(
        '‚ö†Ô∏è Incoh√©rence d√©tect√©e : statut DB = picked_up mais _hasPickedUp = false',
      );
      print('   Correction de l\'√©tat local...');
      setState(() {
        _hasPickedUp = true;
      });
    }

    if (!_hasPickedUp && !isPickedUpInDB) {
      // √âtape 1 : Aller au restaurant
      print('üìç √âtape 1 : Affichage du restaurant et trac√© vers le restaurant');
      // S'assurer qu'on supprime d'abord tout trac√© vers le client s'il existe
      _polylines.removeWhere(
        (p) => p.polylineId == const PolylineId('route-to-client'),
      );
      _markers.removeWhere((m) => m.markerId == const MarkerId('client'));
      print('üóëÔ∏è Trac√© et marqueur client supprim√©s (√©tape 1)');

      await _addRestaurantMarker(restaurantLat, restaurantLng);
      if (_currentPosition != null) {
        await _calculateAndDisplayRouteToRestaurant();
      }
    } else {
      // √âtape 2 : Aller au client
      print('üìç √âtape 2 : Affichage du client et trac√© vers le client');
      // S'assurer qu'on supprime le marqueur et trac√© du restaurant
      _markers.removeWhere((m) => m.markerId == const MarkerId('restaurant'));
      _polylines.removeWhere(
        (p) => p.polylineId == const PolylineId('route-to-restaurant'),
      );
      print('üóëÔ∏è Marqueur et trac√© restaurant supprim√©s (√©tape 2)');

      if (_currentOrder?.deliveryLat != null &&
          _currentOrder?.deliveryLng != null) {
        await _addClientMarker(
          _currentOrder!.deliveryLat!,
          _currentOrder!.deliveryLng!,
        );
        if (_currentPosition != null) {
          await _calculateAndDisplayRouteToClient();
        }
      }
    }
  }

  /// Charger les images de marqueurs (cercles color√©s simples)
  Future<void> _loadMarkerImages() async {
    try {
      // Cr√©er des cercles color√©s simples
      _driverMarkerIcon = await DirectionalMarker.createSimpleMarker(
        color: Colors.blue,
        size: 40.0,
      );

      _clientMarkerIcon = await DirectionalMarker.createSimpleMarker(
        color: Colors.yellow,
        size: 40.0,
      );

      _restaurantMarkerIcon = await DirectionalMarker.createSimpleMarker(
        color: Colors.red,
        size: 40.0,
      );

      print('‚úÖ Marqueurs (cercles color√©s) cr√©√©s avec succ√®s');
    } catch (e) {
      print('‚ùå Erreur lors de la cr√©ation des marqueurs: $e');
      // Utiliser les marqueurs par d√©faut en cas d'erreur
      _driverMarkerIcon = BitmapDescriptor.defaultMarkerWithHue(
        BitmapDescriptor.hueBlue,
      );
      _clientMarkerIcon = BitmapDescriptor.defaultMarkerWithHue(
        BitmapDescriptor.hueGreen,
      );
      _restaurantMarkerIcon = BitmapDescriptor.defaultMarkerWithHue(
        BitmapDescriptor.hueRed,
      );
    }
  }

  /// Calculer le bearing (direction) entre deux positions GPS
  double _calculateBearing(geo.Position previous, geo.Position current) {
    final dLng = (current.longitude - previous.longitude) * (math.pi / 180);
    final lat1Rad = previous.latitude * (math.pi / 180);
    final lat2Rad = current.latitude * (math.pi / 180);

    final y = math.sin(dLng) * math.cos(lat2Rad);
    final x =
        math.cos(lat1Rad) * math.sin(lat2Rad) -
        math.sin(lat1Rad) * math.cos(lat2Rad) * math.cos(dLng);

    double bearing = math.atan2(y, x);
    bearing = bearing * (180 / math.pi);

    return (bearing + 360) % 360; // Normaliser √† 0-360¬∞
  }

  /// Mettre √† jour le marqueur du livreur
  Future<void> _updateDriverMarker() async {
    if (_mapController == null || _currentPosition == null) return;

    try {
      // Calculer le bearing si on a une position pr√©c√©dente et que le mode 3D est activ√©
      if (_is3DMode && _previousPosition != null) {
        final distance = geo.Geolocator.distanceBetween(
          _previousPosition!.latitude,
          _previousPosition!.longitude,
          _currentPosition!.latitude,
          _currentPosition!.longitude,
        );

        // Ne calculer le bearing que si le livreur s'est d√©plac√© d'au moins 5 m√®tres
        if (distance >= 5.0) {
          _currentBearing = _calculateBearing(
            _previousPosition!,
            _currentPosition!,
          );
          print('üß≠ Bearing calcul√©: ${_currentBearing!.toStringAsFixed(1)}¬∞');
        }
      }

      // Calculer le bearing pour l'effet directionnel
      // Ne mettre √† jour le bearing que si on s'est vraiment d√©plac√© (au moins 10 m√®tres)
      double bearing = _currentBearing ?? 0.0;
      if (_previousPosition != null) {
        final distance = geo.Geolocator.distanceBetween(
          _previousPosition!.latitude,
          _previousPosition!.longitude,
          _currentPosition!.latitude,
          _currentPosition!.longitude,
        );

        // Ne calculer le bearing que si on s'est d√©plac√© d'au moins 10 m√®tres
        // Cela √©vite que le marqueur bouge quand on est stationn√©
        if (distance >= 10.0) {
          bearing = _calculateBearing(_previousPosition!, _currentPosition!);
          _currentBearing = bearing; // Sauvegarder le bearing
        }
        // Sinon, utiliser le bearing pr√©c√©dent pour √©viter les mouvements erratiques
      }

      // Supprimer l'ancien marqueur
      _markers.removeWhere((m) => m.markerId == const MarkerId('driver'));

      // Cr√©er le marqueur directionnel avec halo (sans popup)
      final directionalIcon = await DirectionalMarker.createDirectionalMarker(
        color: Colors.blue,
        bearing: bearing,
        showPopup: false,
      );

      // Cr√©er le nouveau marqueur
      final driverMarker = Marker(
        markerId: const MarkerId('driver'),
        position: LatLng(
          _currentPosition!.latitude,
          _currentPosition!.longitude,
        ),
        icon: directionalIcon,
        anchor: const Offset(
          0.5,
          0.5,
        ), // Ancrage au centre pour le marqueur directionnel
      );

      setState(() {
        _markers.add(driverMarker);
      });

      // Centrer la carte sur la position du livreur avec mode 3D
      await _mapController!.animateCamera(
        CameraUpdate.newCameraPosition(
          CameraPosition(
            target: LatLng(
              _currentPosition!.latitude,
              _currentPosition!.longitude,
            ),
            zoom: _is3DMode ? 18.0 : 15.0,
            tilt: _is3DMode ? 60.0 : 0.0,
            bearing: (_is3DMode && _currentBearing != null)
                ? _currentBearing!
                : 0.0,
          ),
        ),
      );

      // Stocker la position actuelle comme position pr√©c√©dente
      _previousPosition = _currentPosition;
    } catch (e) {
      print('‚ùå Erreur lors de la mise √† jour du marqueur livreur: $e');
    }
  }

  /// Ajouter le marqueur du restaurant
  Future<void> _addRestaurantMarker(double lat, double lng) async {
    if (_mapController == null) return;

    try {
      print('üìç Ajout du marqueur restaurant √†: lat=$lat, lng=$lng');

      // S'assurer que l'ic√¥ne est charg√©e
      if (_restaurantMarkerIcon == null) {
        await _loadMarkerImages();
      }

      // Supprimer l'ancien marqueur
      _markers.removeWhere((m) => m.markerId == const MarkerId('restaurant'));

      // Cr√©er le nouveau marqueur
      final restaurantMarker = Marker(
        markerId: const MarkerId('restaurant'),
        position: LatLng(lat, lng),
        icon:
            _restaurantMarkerIcon ??
            BitmapDescriptor.defaultMarkerWithHue(BitmapDescriptor.hueRed),
        anchor: const Offset(0.5, 1.0),
      );

      setState(() {
        _markers.add(restaurantMarker);
      });

      print('‚úÖ Marqueur restaurant ajout√© √† LatLng($lat, $lng)');
    } catch (e) {
      print('‚ùå Erreur lors de l\'ajout du marqueur restaurant: $e');
    }
  }

  /// Ajouter le marqueur du client
  Future<void> _addClientMarker(double lat, double lng) async {
    if (_mapController == null) return;

    try {
      print('üìç Ajout du marqueur client √†: lat=$lat, lng=$lng');

      // V√©rifier si les coordonn√©es sont valides
      if (lat < 4.0 || lat > 6.0 || lng < -5.0 || lng > -3.0) {
        print(
          '‚ö†Ô∏è ATTENTION: Coordonn√©es client suspectes (hors de Grand-Bassam)',
        );
        print(
          '   V√©rifiez si les coordonn√©es ne sont pas invers√©es dans la base de donn√©es',
        );
      }

      // S'assurer que l'ic√¥ne est charg√©e
      if (_clientMarkerIcon == null) {
        await _loadMarkerImages();
      }

      // Supprimer l'ancien marqueur
      _markers.removeWhere((m) => m.markerId == const MarkerId('client'));

      // Cr√©er le nouveau marqueur
      final clientMarker = Marker(
        markerId: const MarkerId('client'),
        position: LatLng(lat, lng),
        icon:
            _clientMarkerIcon ??
            BitmapDescriptor.defaultMarkerWithHue(BitmapDescriptor.hueGreen),
        anchor: const Offset(0.5, 1.0),
      );

      setState(() {
        _markers.add(clientMarker);
      });

      print('‚úÖ Marqueur client ajout√© √† LatLng($lat, $lng)');
    } catch (e) {
      print('‚ùå Erreur lors de l\'ajout du marqueur client: $e');
    }
  }

  /// Calculer et afficher l'itin√©raire vers le restaurant (√âtape 1)
  Future<void> _calculateAndDisplayRouteToRestaurant() async {
    if (_currentPosition == null) {
      print(
        '‚ùå Position livreur manquante pour calculer l\'itin√©raire vers le restaurant',
      );
      return;
    }

    try {
      print('üó∫Ô∏è Calcul de l\'itin√©raire vers le restaurant...');
      print(
        'üìç Position livreur: ${_currentPosition!.latitude}, ${_currentPosition!.longitude}',
      );
      print('üìç Position restaurant: $restaurantLat, $restaurantLng');

      final route = await GoogleMapsRoutingService.getRoute(
        startLat: _currentPosition!.latitude,
        startLng: _currentPosition!.longitude,
        endLat: restaurantLat,
        endLng: restaurantLng,
      );

      if (route != null) {
        setState(() {
          _currentRoute = route;
        });

        print('üìä Route calcul√©e avec ${route.coordinates.length} points');
        if (route.coordinates.length < 10) {
          print(
            '‚ö†Ô∏è ATTENTION: Route avec peu de points (${route.coordinates.length}), peut appara√Ætre rectiligne',
          );
        }

        await _drawRouteToRestaurant(route.coordinates);
        await _centerMapOnRoute(route.coordinates);

        print(
          '‚úÖ Itin√©raire vers restaurant affich√©: ${route.formattedDistance} ‚Ä¢ ${route.formattedDuration}',
        );

        // D√©marrer la mise √† jour p√©riodique de l'itin√©raire
        _startRouteUpdateTimer();
      } else {
        print('‚ùå Impossible de calculer l\'itin√©raire vers le restaurant');
        // Fallback: ligne droite
        await _drawFallbackRouteToRestaurant();
      }
    } catch (e) {
      print('‚ùå Erreur calcul itin√©raire vers restaurant: $e');
      await _drawFallbackRouteToRestaurant();
    }
  }

  /// Calculer et afficher l'itin√©raire vers le client (√âtape 2)
  Future<void> _calculateAndDisplayRouteToClient() async {
    if (_currentPosition == null ||
        _currentOrder?.deliveryLat == null ||
        _currentOrder?.deliveryLng == null) {
      print(
        '‚ùå Positions manquantes pour calculer l\'itin√©raire vers le client',
      );
      print(
        '   Position livreur: ${_currentPosition?.latitude}, ${_currentPosition?.longitude}',
      );
      print(
        '   Position client: ${_currentOrder?.deliveryLat}, ${_currentOrder?.deliveryLng}',
      );
      return;
    }

    try {
      print('üó∫Ô∏è Calcul de l\'itin√©raire vers le client...');
      print(
        'üìç Position livreur: ${_currentPosition!.latitude}, ${_currentPosition!.longitude}',
      );
      print(
        'üìç Position client (deliveryLat/deliveryLng): ${_currentOrder!.deliveryLat}, ${_currentOrder!.deliveryLng}',
      );

      // V√©rifier si les coordonn√©es sont valides (Grand-Bassam est environ 5.2, -4.2)
      if (_currentOrder!.deliveryLat! < 4.0 ||
          _currentOrder!.deliveryLat! > 6.0 ||
          _currentOrder!.deliveryLng! < -5.0 ||
          _currentOrder!.deliveryLng! > -3.0) {
        print(
          '‚ö†Ô∏è ATTENTION: Coordonn√©es de livraison suspectes (hors de Grand-Bassam)',
        );
        print('   Les coordonn√©es semblent incorrectes ou invers√©es');
      }

      final route = await GoogleMapsRoutingService.getRoute(
        startLat: _currentPosition!.latitude,
        startLng: _currentPosition!.longitude,
        endLat: _currentOrder!.deliveryLat!,
        endLng: _currentOrder!.deliveryLng!,
      );

      if (route != null) {
        setState(() {
          _currentRoute = route;
        });

        print('üìä Route calcul√©e avec ${route.coordinates.length} points');
        if (route.coordinates.length < 10) {
          print(
            '‚ö†Ô∏è ATTENTION: Route avec peu de points (${route.coordinates.length}), peut appara√Ætre rectiligne',
          );
        }

        await _drawRouteToClient(route.coordinates);
        await _centerMapOnRoute(route.coordinates);

        print(
          '‚úÖ Itin√©raire vers client affich√©: ${route.formattedDistance} ‚Ä¢ ${route.formattedDuration}',
        );

        // D√©marrer la mise √† jour p√©riodique de l'itin√©raire
        _startRouteUpdateTimer();
      } else {
        print('‚ùå Impossible de calculer l\'itin√©raire vers le client');
        // Fallback: ligne droite
        await _drawFallbackRouteToClient();
      }
    } catch (e) {
      print('‚ùå Erreur calcul itin√©raire vers client: $e');
      await _drawFallbackRouteToClient();
    }
  }

  /// Mettre √† jour l'itin√©raire (appel√© p√©riodiquement)
  Future<void> _updateRoute() async {
    if (_currentPosition == null) return;

    // Mettre √† jour l'itin√©raire toutes les 30 secondes selon l'√©tape
    _routeUpdateTimer?.cancel();
    _routeUpdateTimer = Timer(const Duration(seconds: 30), () {
      if (!_hasPickedUp) {
        _calculateAndDisplayRouteToRestaurant();
      } else if (_currentOrder?.deliveryLat != null &&
          _currentOrder?.deliveryLng != null) {
        _calculateAndDisplayRouteToClient();
      }
    });
  }

  /// D√©marrer le timer de mise √† jour de l'itin√©raire
  void _startRouteUpdateTimer() {
    _routeUpdateTimer?.cancel();
    _routeUpdateTimer = Timer.periodic(const Duration(seconds: 30), (timer) {
      if (_currentPosition != null) {
        if (!_hasPickedUp) {
          // √âtape 1 : vers le restaurant
          _calculateAndDisplayRouteToRestaurant();
        } else if (_currentOrder?.deliveryLat != null &&
            _currentOrder?.deliveryLng != null) {
          // √âtape 2 : vers le client
          _calculateAndDisplayRouteToClient();
        } else {
          timer.cancel();
        }
      } else {
        timer.cancel();
      }
    });
  }

  /// Dessiner l'itin√©raire vers le restaurant sur la carte
  Future<void> _drawRouteToRestaurant(List<LatLng> coordinates) async {
    if (_mapController == null) return;

    try {
      // Supprimer les anciennes polylines
      _polylines.removeWhere(
        (p) => p.polylineId == const PolylineId('route-to-restaurant'),
      );
      _polylines.removeWhere(
        (p) => p.polylineId == const PolylineId('route-to-client'),
      );

      // Cr√©er la nouvelle polyline vers le restaurant avec geodesic pour suivre la route r√©elle
      final routePolyline = Polyline(
        polylineId: const PolylineId('route-to-restaurant'),
        points: coordinates,
        color: const Color(0xFFFF6B35), // Orange
        width: 5,
        geodesic:
            true, // Suivre la courbure de la Terre pour une route plus r√©aliste
        patterns: [], // Pas de pattern pour une ligne continue
      );

      setState(() {
        _polylines.add(routePolyline);
      });
    } catch (e) {
      print('‚ùå Erreur lors du dessin de l\'itin√©raire vers le restaurant: $e');
    }
  }

  /// Dessiner l'itin√©raire vers le client sur la carte
  Future<void> _drawRouteToClient(List<LatLng> coordinates) async {
    if (_mapController == null) return;

    try {
      // Supprimer les anciennes polylines
      _polylines.removeWhere(
        (p) => p.polylineId == const PolylineId('route-to-restaurant'),
      );
      _polylines.removeWhere(
        (p) => p.polylineId == const PolylineId('route-to-client'),
      );

      // Cr√©er la nouvelle polyline vers le client avec geodesic pour suivre la route r√©elle
      final routePolyline = Polyline(
        polylineId: const PolylineId('route-to-client'),
        points: coordinates,
        color: const Color(0xFF4CAF50), // Vert pour diff√©rencier du restaurant
        width: 5,
        geodesic:
            true, // Suivre la courbure de la Terre pour une route plus r√©aliste
        patterns: [], // Pas de pattern pour une ligne continue
      );

      setState(() {
        _polylines.add(routePolyline);
      });
    } catch (e) {
      print('‚ùå Erreur lors du dessin de l\'itin√©raire vers le client: $e');
    }
  }

  /// Itin√©raire de secours vers le restaurant (ligne droite)
  Future<void> _drawFallbackRouteToRestaurant() async {
    if (_currentPosition == null) return;

    final fallbackRoute = [
      LatLng(_currentPosition!.latitude, _currentPosition!.longitude),
      LatLng(restaurantLat, restaurantLng),
    ];

    await _drawRouteToRestaurant(fallbackRoute);
    print(
      '‚ö†Ô∏è Utilisation de l\'itin√©raire de secours vers le restaurant (ligne droite)',
    );
  }

  /// Itin√©raire de secours vers le client (ligne droite)
  Future<void> _drawFallbackRouteToClient() async {
    if (_currentPosition == null ||
        _currentOrder?.deliveryLat == null ||
        _currentOrder?.deliveryLng == null)
      return;

    final fallbackRoute = [
      LatLng(_currentPosition!.latitude, _currentPosition!.longitude),
      LatLng(_currentOrder!.deliveryLat!, _currentOrder!.deliveryLng!),
    ];

    await _drawRouteToClient(fallbackRoute);
    print(
      '‚ö†Ô∏è Utilisation de l\'itin√©raire de secours vers le client (ligne droite)',
    );
  }

  /// Centrer la carte sur l'itin√©raire
  Future<void> _centerMapOnRoute(List<LatLng> coordinates) async {
    if (_mapController == null || coordinates.isEmpty) return;

    try {
      // Calculer les bounds de l'itin√©raire
      double minLat = coordinates.first.latitude;
      double maxLat = coordinates.first.latitude;
      double minLng = coordinates.first.longitude;
      double maxLng = coordinates.first.longitude;

      for (final coord in coordinates) {
        if (coord.latitude < minLat) minLat = coord.latitude;
        if (coord.latitude > maxLat) maxLat = coord.latitude;
        if (coord.longitude < minLng) minLng = coord.longitude;
        if (coord.longitude > maxLng) maxLng = coord.longitude;
      }

      // Calculer le centre de l'itin√©raire
      final centerLat = (minLat + maxLat) / 2;
      final centerLng = (minLng + maxLng) / 2;

      // Calculer le zoom approximatif bas√© sur la distance
      final latDiff = maxLat - minLat;
      final lngDiff = maxLng - minLng;
      final maxDiff = latDiff > lngDiff ? latDiff : lngDiff;
      double zoom = _is3DMode
          ? 18.0
          : 15.0; // Zoom de base plus √©lev√© en mode 3D
      if (maxDiff > 0.1) {
        zoom = _is3DMode ? 14.0 : 12.0;
      } else if (maxDiff > 0.05) {
        zoom = _is3DMode ? 15.0 : 13.0;
      } else if (maxDiff > 0.01) {
        zoom = _is3DMode ? 16.0 : 14.0;
      }

      await _mapController!.animateCamera(
        CameraUpdate.newCameraPosition(
          CameraPosition(
            target: LatLng(centerLat, centerLng),
            zoom: zoom,
            tilt: _is3DMode ? 60.0 : 0.0,
            bearing: (_is3DMode && _currentBearing != null)
                ? _currentBearing!
                : 0.0,
          ),
        ),
      );
    } catch (e) {
      print('‚ùå Erreur lors du centrage sur l\'itin√©raire: $e');
    }
  }

  Future<void> _markAsPickedUp() async {
    if (_currentDriver == null || _currentOrder == null) return;

    try {
      final success = await ActiveDeliveryService.markAsPickedUp(
        _currentOrder!.id,
        _currentDriver!.id,
      );

      if (success && mounted) {
        setState(() {
          _hasPickedUp = true;
        });

        // Supprimer le marqueur du restaurant
        _markers.removeWhere((m) => m.markerId == const MarkerId('restaurant'));

        // Supprimer le trac√© vers le restaurant
        _polylines.removeWhere(
          (p) => p.polylineId == const PolylineId('route-to-restaurant'),
        );

        // Ajouter le marqueur du client et calculer l'itin√©raire vers le client
        if (_currentOrder!.deliveryLat != null &&
            _currentOrder!.deliveryLng != null) {
          await _addClientMarker(
            _currentOrder!.deliveryLat!,
            _currentOrder!.deliveryLng!,
          );
          await _calculateAndDisplayRouteToClient();
        }

        final state = ActiveDeliveryState.fromOrder(
          _currentOrder!,
          hasPickedUp: true,
        );
        await StatePersistenceService.saveActiveDelivery(state);

        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(
            content: Text('Commande r√©cup√©r√©e ! Direction le client'),
            backgroundColor: Colors.green,
          ),
        );
      }
    } catch (e) {
      print('‚ùå Erreur: $e');
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text('Erreur: $e'), backgroundColor: Colors.red),
      );
    }
  }

  Future<void> _markAsArrived() async {
    if (_currentDriver == null || _currentOrder == null) return;

    try {
      final success = await ActiveDeliveryService.markAsArrived(
        _currentOrder!.id,
        _currentDriver!.id,
      );

      if (success && mounted) {
        setState(() {
          _hasArrived = true;
        });

        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(
            content: Text('Vous √™tes arriv√© au point de livraison'),
            backgroundColor: Colors.green,
          ),
        );
      }
    } catch (e) {
      print('‚ùå Erreur: $e');
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text('Erreur: $e'), backgroundColor: Colors.red),
      );
    }
  }

  void _showCompletionModal() {
    showModalBottomSheet(
      context: context,
      builder: (context) => DeliveryCompletionModal(
        onQRCodeSelected: _scanQRCode,
        onCodeSelected: _enterDeliveryCode,
      ),
    );
  }

  void _scanQRCode() {
    final qrController = TextEditingController();

    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('Scanner le QR code'),
        content: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            const Text(
              'Entrez le code QR scann√© (format: order:123)',
              textAlign: TextAlign.center,
            ),
            const SizedBox(height: 16),
            TextField(
              controller: qrController,
              decoration: const InputDecoration(
                hintText: 'order:123',
                border: OutlineInputBorder(),
              ),
              autofocus: true,
            ),
            const SizedBox(height: 8),
            const Text(
              'Ou utilisez l\'appareil photo pour scanner',
              style: TextStyle(fontSize: 12, color: Colors.grey),
              textAlign: TextAlign.center,
            ),
          ],
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context),
            child: const Text('Annuler'),
          ),
          ElevatedButton(
            onPressed: () async {
              final qrCode = qrController.text.trim();
              if (qrCode.isNotEmpty) {
                Navigator.pop(context);
                await _completeDelivery(qrCode: qrCode);
              } else {
                ScaffoldMessenger.of(context).showSnackBar(
                  const SnackBar(
                    content: Text('Veuillez entrer un code QR'),
                    backgroundColor: Colors.red,
                  ),
                );
              }
            },
            child: const Text('Valider'),
          ),
        ],
      ),
    );
  }

  void _enterDeliveryCode() {
    final codeController = TextEditingController();

    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('Code de confirmation'),
        content: TextField(
          controller: codeController,
          keyboardType: TextInputType.number,
          decoration: const InputDecoration(
            hintText: 'Entrez le code √† 6 chiffres',
          ),
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context),
            child: const Text('Annuler'),
          ),
          ElevatedButton(
            onPressed: () async {
              final code = codeController.text.trim();
              if (code.length == 6 && RegExp(r'^[0-9]{6}$').hasMatch(code)) {
                Navigator.pop(context);
                await _completeDelivery(code: code);
              } else {
                ScaffoldMessenger.of(context).showSnackBar(
                  const SnackBar(
                    content: Text('Le code doit contenir 6 chiffres'),
                    backgroundColor: Colors.red,
                  ),
                );
              }
            },
            child: const Text('Valider'),
          ),
        ],
      ),
    );
  }

  /// Appeler le client
  Future<void> _callCustomer(String phoneNumber) async {
    try {
      final Uri phoneUri = Uri(scheme: 'tel', path: phoneNumber);
      if (await canLaunchUrl(phoneUri)) {
        await launchUrl(phoneUri);
        print('‚úÖ Appel lanc√© vers: $phoneNumber');
      } else {
        if (mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            const SnackBar(
              content: Text('Impossible d\'ouvrir l\'application t√©l√©phone'),
              backgroundColor: Colors.red,
            ),
          );
        }
      }
    } catch (e) {
      print('‚ùå Erreur lors de l\'appel: $e');
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('Erreur: $e'), backgroundColor: Colors.red),
        );
      }
    }
  }

  /// Basculer entre mode 2D et 3D
  Future<void> _toggle3DMode() async {
    setState(() {
      _is3DMode = !_is3DMode;
    });

    print('üîÑ Mode 3D ${_is3DMode ? "activ√©" : "d√©sactiv√©"}');

    // R√©appliquer les param√®tres de cam√©ra imm√©diatement
    if (_mapController != null && _currentPosition != null) {
      await _mapController!.animateCamera(
        CameraUpdate.newCameraPosition(
          CameraPosition(
            target: LatLng(
              _currentPosition!.latitude,
              _currentPosition!.longitude,
            ),
            zoom: _is3DMode ? 18.0 : 15.0, // Zoom plus √©lev√© en mode 3D
            tilt: _is3DMode ? 60.0 : 0.0,
            bearing: (_is3DMode && _currentBearing != null)
                ? _currentBearing!
                : 0.0,
          ),
        ),
      );
    }
  }

  Future<void> _completeDelivery({String? code, String? qrCode}) async {
    if (_currentDriver == null || _currentOrder == null) return;

    try {
      // D√©sactiver le mode 3D avant de quitter
      _is3DMode = false;
      _previousPosition = null;
      _currentBearing = null;

      final success = await ActiveDeliveryService.completeDelivery(
        _currentOrder!.id,
        _currentDriver!.id,
        deliveryCode: code,
        qrCode: qrCode,
      );

      if (success && mounted) {
        await StatePersistenceService.clearActiveDelivery();
        await DriverLocationService.stopLocationTracking();

        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(
            content: Text('Livraison finalis√©e avec succ√®s !'),
            backgroundColor: Colors.green,
          ),
        );

        context.go('/home');
      } else {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(
            content: Text('Code invalide ou expir√©'),
            backgroundColor: Colors.red,
          ),
        );
      }
    } catch (e) {
      print('‚ùå Erreur: $e');
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text('Erreur: $e'), backgroundColor: Colors.red),
      );
    }
  }

  @override
  Widget build(BuildContext context) {
    if (_isLoading) {
      return const Scaffold(body: Center(child: CircularProgressIndicator()));
    }

    if (_currentOrder == null) {
      return Scaffold(
        appBar: AppBar(title: const Text('Erreur')),
        body: const Center(child: Text('Commande introuvable')),
      );
    }

    return Scaffold(
      body: Stack(
        children: [
          // Carte pleine √©cran
          GoogleMap(
            key: const ValueKey('map'),
            initialCameraPosition: CameraPosition(
              target: _currentPosition != null
                  ? LatLng(
                      _currentPosition!.latitude,
                      _currentPosition!.longitude,
                    )
                  : (_currentOrder!.deliveryLat != null &&
                            _currentOrder!.deliveryLng != null
                        ? LatLng(
                            _currentOrder!.deliveryLat!,
                            _currentOrder!.deliveryLng!,
                          )
                        : const LatLng(5.3600, -4.0083)),
              zoom: _is3DMode ? 18.0 : 15.0, // Zoom plus √©lev√© en mode 3D
              tilt: _is3DMode ? 60.0 : 0.0,
              bearing: (_is3DMode && _currentBearing != null)
                  ? _currentBearing!
                  : 0.0,
            ),
            onMapCreated: _onMapCreated,
            mapType: MapType.normal,
            markers: _markers,
            polylines: _polylines,
            myLocationEnabled:
                false, // D√©sactiv√© pour √©viter le doublon avec notre marqueur personnalis√©
            myLocationButtonEnabled: false,
            tiltGesturesEnabled: true,
            zoomGesturesEnabled: true,
            scrollGesturesEnabled: true,
            rotateGesturesEnabled: true,
          ),

          // Bouton toggle mode 3D
          Positioned(
            top: 50,
            right: 16,
            child: FloatingActionButton(
              mini: true,
              backgroundColor: _is3DMode ? Colors.orange : Colors.grey[600],
              onPressed: _toggle3DMode,
              child: Icon(
                _is3DMode ? Icons.view_in_ar : Icons.map,
                color: Colors.white,
              ),
              tooltip: _is3DMode
                  ? 'D√©sactiver le mode 3D'
                  : 'Activer le mode 3D',
            ),
          ),

          // Bottom sheet draggable avec les informations de commande
          DraggableScrollableSheet(
            initialChildSize: 0.35,
            minChildSize: 0.2,
            maxChildSize: 0.9,
            builder: (context, scrollController) {
              return Container(
                decoration: const BoxDecoration(
                  color: Colors.white,
                  borderRadius: BorderRadius.only(
                    topLeft: Radius.circular(20),
                    topRight: Radius.circular(20),
                  ),
                  boxShadow: [
                    BoxShadow(
                      color: Colors.black12,
                      blurRadius: 10,
                      offset: Offset(0, -2),
                    ),
                  ],
                ),
                child: Column(
                  children: [
                    // Indicateur de glissement
                    Container(
                      margin: const EdgeInsets.only(top: 12, bottom: 8),
                      width: 40,
                      height: 4,
                      decoration: BoxDecoration(
                        color: Colors.grey[300],
                        borderRadius: BorderRadius.circular(2),
                      ),
                    ),

                    // Contenu scrollable
                    Expanded(
                      child: SingleChildScrollView(
                        controller: scrollController,
                        padding: const EdgeInsets.all(16),
                        child: Column(
                          crossAxisAlignment: CrossAxisAlignment.start,
                          children: [
                            // Informations de la commande
                            Text(
                              'Commande #${_currentOrder!.id}',
                              style: const TextStyle(
                                fontSize: 24,
                                fontWeight: FontWeight.bold,
                              ),
                            ),
                            const SizedBox(height: 8),
                            Row(
                              children: [
                                Expanded(
                                  child: Column(
                                    crossAxisAlignment:
                                        CrossAxisAlignment.start,
                                    children: [
                                      Text(
                                        'Client: ${_currentOrder!.customerName ?? 'Client'}',
                                        style: const TextStyle(
                                          fontSize: 16,
                                          fontWeight: FontWeight.w600,
                                        ),
                                      ),
                                      if (_currentOrder!
                                          .customerPhone
                                          .isNotEmpty)
                                        Text(
                                          _currentOrder!.customerPhone,
                                          style: TextStyle(
                                            fontSize: 14,
                                            color: Colors.grey[600],
                                          ),
                                        ),
                                    ],
                                  ),
                                ),
                                if (_currentOrder!.customerPhone.isNotEmpty)
                                  IconButton(
                                    icon: const Icon(
                                      Icons.phone,
                                      color: Colors.green,
                                    ),
                                    onPressed: () => _callCustomer(
                                      _currentOrder!.customerPhone,
                                    ),
                                    tooltip: 'Appeler le client',
                                    style: IconButton.styleFrom(
                                      backgroundColor: Colors.green[50],
                                      padding: const EdgeInsets.all(12),
                                    ),
                                  ),
                              ],
                            ),
                            const SizedBox(height: 4),
                            Text(
                              'Adresse: ${_currentOrder!.deliveryAddress ?? 'N/A'}',
                              style: TextStyle(
                                fontSize: 14,
                                color: Colors.grey[600],
                              ),
                            ),
                            const SizedBox(height: 16),

                            // Card de progression de route style Uber/Glovo
                            if (_currentRoute != null &&
                                _currentPosition != null)
                              RouteProgressCard(
                                currentStep: _hasPickedUp
                                    ? 'Vers client'
                                    : 'Vers restaurant',
                                distanceRemaining: _currentRoute!.distance,
                                eta: Duration(
                                  seconds: _currentRoute!.duration.round(),
                                ),
                                progress: _calculateRouteProgress(),
                              ),
                            const SizedBox(height: 16),

                            // Carte de statut de livraison
                            DeliveryStatusCard(
                              order: _currentOrder!,
                              hasPickedUp: _hasPickedUp,
                              hasArrived: _hasArrived,
                            ),
                            const SizedBox(height: 16),

                            // Panneau d'actions
                            DeliveryActionsPanel(
                              hasPickedUp: _hasPickedUp,
                              hasArrived: _hasArrived,
                              onMarkPickedUp: _markAsPickedUp,
                              onMarkArrived: _markAsArrived,
                              onCompleteDelivery: _showCompletionModal,
                            ),
                          ],
                        ),
                      ),
                    ),
                  ],
                ),
              );
            },
          ),
        ],
      ),
    );
  }

  /// Calcule la progression sur la route (0.0 √† 1.0)
  double _calculateRouteProgress() {
    if (_currentRoute == null || _currentPosition == null) return 0.0;

    if (!_hasPickedUp) {
      // √âtape 1: Vers le restaurant
      // Calculer la distance restante jusqu'au restaurant
      final remainingDistance = geo.Geolocator.distanceBetween(
        _currentPosition!.latitude,
        _currentPosition!.longitude,
        restaurantLat,
        restaurantLng,
      );
      // Progression approximative bas√©e sur la distance restante
      final progress =
          1.0 - (remainingDistance / _currentRoute!.distance).clamp(0.0, 1.0);
      return progress;
    } else if (_currentOrder?.deliveryLat != null &&
        _currentOrder?.deliveryLng != null) {
      // √âtape 2: Vers le client
      final remainingDistance = geo.Geolocator.distanceBetween(
        _currentPosition!.latitude,
        _currentPosition!.longitude,
        _currentOrder!.deliveryLat!,
        _currentOrder!.deliveryLng!,
      );
      final progress =
          1.0 - (remainingDistance / _currentRoute!.distance).clamp(0.0, 1.0);
      return progress;
    }

    return 0.0;
  }
}
